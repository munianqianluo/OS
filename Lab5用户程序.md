# LAB5用户程序

## 实验目的

- 了解第一个用户进程创建过程
- 了解系统调用框架的实现机制
- 了解ucore如何实现系统调用sys_fork/sys_exec/sys_exit/sys_wait来进行进程管理

## 实验内容

#### 练习0：填写已有实验

#### 练习1: 加载应用程序并执行（需要编码）

**do_execv**函数调用`load_icode`（位于kern/process/proc.c中）来加载并解析一个处于内存中的ELF执行文件格式的应用程序。需要补充`load_icode`的第6步，建立相应的用户内存空间来放置应用程序的代码段、数据段等，且要设置好`proc_struct`结构中的成员变量trapframe中的内容，确保在执行此进程后，能够从应用程序设定的起始执行地址开始执行。需设置正确的trapframe内容。

请简要说明设计实现过程。

- 请简要描述这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。

##### 答：

为了让用户级别的进程可以从内核返回到用户模式，所以：

tf->gpr.sp 应该是用户栈的顶部（即 sp 的值）。

tf->status 应该适用于用户程序（即 sstatus 的值）。

tf->epc 应该是用户程序的入口点（即 sepc 的值）。

```c
tf->gpr.sp = USTACKTOP;
tf->epc = elf->e_entry;
tf->status = sstatus & ~(SSTATUS_SPP | SSTATUS_SPIE);
```

将 tf 结构中的通用寄存器（gpr）中的栈指针（sp）设置为 USTACKTOP。这表明将用户栈的顶部地址赋给用户进程的栈指针。

将 tf 结构中的状态寄存器（status）设置为给定的 sstatus，但清除了 SPP（Supervisor PreviousPrivilege）和 SPIE（Supervisor Previous Interrupt Enable）标志。这两个标志通常用于处理从内核返回用户模式时的特权级别和中断使能状态。

将 tf 结构中的程序计数器（epc）设置为 ELF 文件的入口点地址。这是用户程序的启动地址，将控制权转移到用户程序的执行起点。 

##### 用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。

这其实就是 do_execve 函数的工作过程：

- 调用schedule函数，调度器占用了CPU的资源之后，用户态进程调用了exec系统调用，从而转入到了系统调用的处理过程，将控制权转移到了 syscall.c 中的 syscall 函数，然后根据系统调用号转移给了 sys_exec 函数，在该函数中调用了 do_execve 函数来完成指定应用程序的加载。

- 在 do_execve 函数中，先获取当前进程的内存管理结构，将当前进程的页表换用内核页表之后，调用 load_icode 函数给用户进程建立一个能够让用户进程正常运行的用户环境，即以下过程：

- 调用mm_create函数来申请进程的内存管理数据结构mm所需内存空间，并对mm进行初始化。

- 调用setup_pgdir来申请一个页目录表所需的一个页大小的内存空间，并把描述ucore内核虚空间映射的内核页表（boot_pgdir所指）的内容拷贝到此新目录表中，最后mm->pgdir指向此页目录表，这就是进程新的页目录表了，且能够正确映射内核。

- 根据应用程序执行码的起始位置来解析此ELF格式的执行程序，并调用mm_map函数根据ELF格式的执行程序说明的各个段（代码段、数据段、BSS段等）的起始位置和大小建立对应的vma结构，并把vma插入到mm结构中，从而表明了用户进程的合法用户态虚拟地址空间。

- 调用根据执行程序各个段的大小分配物理内存空间，并根据执行程序各个段的起始位置确定虚拟地址，并在页表中建立好物理地址和虚拟地址的映射关系，然后把执行程序各个段的内容拷贝到相应的内核虚拟地址中，至此应用程序执行码和数据已经根据编译时设定地址放置到虚拟内存中了；

- 需要给用户进程设置用户栈，为此调用mm_mmap函数建立用户栈的vma结构，明确用户栈的位置在用户虚空间的顶端，大小为256个页，即1MB，并分配一定数量的物理内存且建立好栈的虚地址<–>物理地址映射关系；

- 至此,进程内的内存管理vma和mm数据结构已经建立完成，于是把mm->pgdir赋值到cr3寄存器中，即更新了用户进程的虚拟内存空间，此时的initproc已经被hello的代码和数据覆盖，成为了第一个用户进程，但此时这个用户进程的执行现场还没建立好；

- 先清空进程的中断帧，再重新设置进程的中断帧，使得在执行中断返回指令“iret”后，能够让CPU转到用户态特权级，并回到用户态内存空间，使用用户态的代码段、数据段和堆栈，且能够跳转到用户进程的第一条指令执行，并确保在用户态能够响应中断。

#### 练习2: 父进程复制自己的内存空间给子进程（需要编码）

创建子进程的函数`do_fork`在执行中将拷贝当前进程（即父进程）的用户内存地址空间中的合法内容到新进程中（子进程），完成内存资源的复制。具体是通过`copy_range`函数（位于kern/mm/pmm.c中）实现的，请补充`copy_range`的实现，确保能够正确执行。

请简要说明设计实现过程。

- 如何设计实现`Copy on Write`机制？给出概要设计。

##### 答：

do_fork函数调用copy_mm函数实现进程mm的复制，后者根据clone_flags & CLONE_VM的取值调用了dup_mmap函数。dup_mmap函数在两个进程之间复制内存映射关系。具体来说，该函数的两个参数分别表示目标进程和源进程的内存管理结构mm。然后通过循环迭代，每次创建一个新的内存映射区域（vma），然后将其插入到目标进程的mm中，之后调用copy_range函数将源进程的内存映射区域的内容复制到目标进程中。

```c
int copy_range(pde_t *to, pde_t *from, uintptr_t start, uintptr_t end,
               bool share) {
    assert(start % PGSIZE == 0 && end % PGSIZE == 0);
    assert(USER_ACCESS(start, end));
    // copy content by page unit.
    do {
        // call get_pte to find process A's pte according to the addr start
        pte_t *ptep = get_pte(from, start, 0), *nptep;
        if (ptep == NULL) {
            start = ROUNDDOWN(start + PTSIZE, PTSIZE);
            continue;
        }
        // call get_pte to find process B's pte according to the addr start. If
        // pte is NULL, just alloc a PT
        if (*ptep & PTE_V) {
            if ((nptep = get_pte(to, start, 1)) == NULL) {
                return -E_NO_MEM;
            }
            uint32_t perm = (*ptep & PTE_USER);
            // get page from ptep
            struct Page *page = pte2page(*ptep);
            // alloc a page for process B
            struct Page *npage = alloc_page();
            assert(page != NULL);
            assert(npage != NULL);
            int ret = 0;   
            void *src_kvaddr = page2kva(page);
            void *dst_kvaddr = page2kva(npage);
            memcpy(dst_kvaddr, src_kvaddr, PGSIZE);
            ret = page_insert(to, npage, start, perm);
            assert(ret == 0);
        }
        start += PGSIZE;
    } while (start != 0 && start < end);
    return 0;
}


```

函数首先通过断言确保start和end是页面对齐且属于用户地址空间的。然后通过循环每次处理一页数据。在每次迭代中，函数调用 get_pte 函数查找源进程 A 的页表项（pte），如果不存在，则跳过当前页并继续下一个页面。如果 pte 存在，则再调用 get_pte 函数查找目标进程 B 的页表项（nptep）。如果 nptep 不存在，则分配一个新的页表并建立映射。

接下来，函数调用 alloc_page 函数为进程 B 分配一个新的物理页面（npage）。然后，函数将源进程 A的物理页面（page）中的内容复制到新的物理页面中。具体实现上，就是通过page2kva函数获取到目标进程和源进程各自页面的虚拟地址，然后使用memcpy函数实现复制。页面复制完成后，函数再调用page_insert 函数将新的物理页面与目标进程 B 的线性地址建立映射。

##### 如何设计实现`Copy on Write`机制

Copy on Write（COW）机制是一种在多进程共享资源时，延迟复制的技术。它允许多个进程共享同一块内存空间，直到其中一个进程尝试修改数据时，才会进行实际的复制操作，以确保数据的独立性。

在设计该机制时，考虑到了以下两点：

未修改时，如何实现内存共享？修改时，如何实现资源复制以及之后的数据一致性？

针对以上两点，进行了如下设计：

- 内存管理：
  
  使用页表来跟踪进程间共享的内存页，记录每个页的引用计数。
  
  当进程创建时，内核分配一块共享内存区域，并将该区域映射到多个进程的地址空间中。

- 写时复制实现：
  
  当进程试图写入一个共享页时，内核会触发页故障：检查被访问的页是否是共享的。
  
  如果引用计数为1，表示该页只有一个进程在使用，直接允许修改。
  
  如果引用计数大于1，执行复制操作：分配一个新的页，并将原始页的内容复制到新页中。更新进程的页表，使其指向新的页。更新引用计数和页表条目，确保进程间的独立性。

- 引用计数：
  
  引用计数用于跟踪共享页的引用情况。每当一个新的进程开始使用某个共享页时，引用计数增加；当进程停止使用该页时，引用计数减少。
  
  当引用计数为0时，释放对应的页。

- 数据一致性：
  
  确保在进行写时复制时，修改后的页仅影响到修改它的进程，而不影响其他进程。
  
  维护页表和引用计数，以确保每个进程都能正确访问到自己的数据，并且在修改时能够获得独立的拷贝。

- 同步机制：
  
  在进行写时复制时，需要采取同步机制以避免多个进程同时修改相同的共享页。可以使用锁或其他同步手段来确保数据的一致性和正确性。 

#### 练习3: 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现（不需要编码）

请在实验报告中简要说明你对 fork/exec/wait/exit函数的分析。并回答如下问题：

- 请分析fork/exec/wait/exit的执行流程。重点关注哪些操作是在用户态完成，哪些是在内核态完成？内核态与用户态程序是如何交错执行的？内核态执行结果是如何返回给用户程序的？
- 请给出ucore中一个用户态进程的执行状态生命周期图（包执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）。（字符方式画即可）

执行：make grade。如果所显示的应用程序检测都输出ok，则基本正确。（使用的是qemu-1.0.1）

##### 答：

①fork：执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。在子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID。我们可以通过fork返回的值来判断当前进程是子进程还是父进程

// 调用过程：fork->SYS_fork->do_fork + wakeup_proc

// wakeup_proc 函数主要是将进程的状态设置为等待。

// do_fork()

1、分配并初始化进程控制块(alloc_proc 函数);

2、分配并初始化内核栈(setup_stack 函数);

3、根据 clone_flag标志复制或共享进程内存管理结构(copy_mm 函数);

4、设置进程在内核(将来也包括用户态)正常运行和调度所需的中断帧和执行上下文(copy_thread 函数);

5、把设置好的进程控制块放入hash_list 和 proc_list 两个全局进程链表中;

6、自此,进程已经准备好执行了,把进程状态设置为“就绪”态;

7、设置返回码为子进程的 id 号。

用户态程序调用sys_fork()系统调用，通过syscall进入内核态。

内核态处理sys_fork()系统调用，调用do_fork()函数创建子进程，完成后返回到用户态。②exit：会把一个退出码error_code传递给ucore，ucore通过执行内核函数do_exit来完成对当前进程的退出处理，主要工作简单地说就是回收当前进程所占的大部分内存资源，并通知父进程完成最后的回收工作。

// 调用过程： SYS_exit->exit

1、先判断是否是用户进程，如果是，则开始回收此用户进程所占用的用户态虚拟内存空间;

2、设置当前进程的中hi性状态为PROC_ZOMBIE，然后设置当前进程的退出码为error_code。表明此时这个进程已经无法再被调度了，只能等待父进程来完成最后的回收工作（主要是回收该子进程的内核栈、进程控制块）

3、如果当前父进程已经处于等待子进程的状态，即父进程的wait_state被置为WT_CHILD，则此时就可以唤醒父进程，让父进程来帮子进程完成最后的资源回收工作。

4、如果当前进程还有子进程,则需要把这些子进程的父进程指针设置为内核线程init,且各个子进程指针需要插入到init的子进程链表中。如果某个子进程的执行状态是 PROC_ZOMBIE,则需要唤醒 init来完成对此子进程的最后回收工作。

5、执行schedule()调度函数，选择新的进程执行。

用户态程序调用sys_exit()系统调用，通过syscall进入内核态。

内核态处理sys_exit()系统调用，调用do_exit()函数结束当前进程，最终返回到用户态。

③execve：完成用户进程的创建工作。首先为加载新的执行码做好用户态内存空间清空准备。接下来的一步是加载应用程序执行码到当前进程的新创建的用户态虚拟空间中。

// 调用过程： SYS_exec->do_execve

1、首先为加载新的执行码做好用户态内存空间清空准备。如果mm不为NULL，则设置页表为内核空间页表，且进一步判断mm的引用计数减1后是否为0，如果为0，则表明没有进程再需要此进程所占用的内存空间，为此将根据mm中的记录，释放进程所占用户空间内存和进程页表本身所占空间。最后把当前进程的mm内存管理指针为空。

2、接下来是加载应用程序执行码到当前进程的新创建的用户态虚拟空间中。之后就是调用load_icode从而使之准备好执行。

用户态程序调用sys_exec()系统调用，通过syscall进入内核态。

内核态处理sys_exec()系统调用，调用do_execve()函数加载新的程序，但由于当前是在S mode下，无法直接进行上下文切换。因此使用ebreak产生断点中断，转发到syscall()函数，在该函数 中完成上下文切换，最终返回到用户态。

④wait：等待任意子进程的结束通知。wait_pid函数等待进程id号为pid的子进程结束通知。这两个函数最终访问sys_wait系统调用接口让ucore来完成对子进程的最后回收工作。

// 调用过程： SYS_wait->do_wait

1、 如果 pid!=0，表示只找一个进程 id 号为 pid 的退出状态的子进程，否则找任意一个处于退出状态的子进程;

2、 如果此子进程的执行状态不为PROC_ZOMBIE，表明此子进程还没有退出，则当前进程设置执行状态为PROC_SLEEPING（睡眠），睡眠原因为WT_CHILD(即等待子进程退出)，调用schedule()函数选择新的进程执行，自己睡眠等待，如果被唤醒，则重复跳回步骤 1 处执行;

3、 如果此子进程的执行状态为 PROC_ZOMBIE，表明此子进程处于退出状态，需要当前进程(即子进程的父进程)完成对子进程的最终回收工作，即首先把子进程控制块从两个进程队列proc_list和hash_list中删除，并释放子进程的内核堆栈和进程控制块。自此，子进程才彻底地结束了它的执行过程，它所占用的所有资源均已释放。

用户态程序调用sys_wait()系统调用，通过syscall进入内核态。

内核态处理sys_wait()系统调用，调用do_wait()函数等待子进程退出，完成后返回到用户态。请给出ucore中一个用户态进程的执行状态生命周期图（包执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）

<img src="file:///C:/Users/鑫鑫/AppData/Roaming/marktext/images/2023-12-10-20-06-18-image.png" title="" alt="" width="412">

#### 扩展练习 Challenge

1. 实现 Copy on Write （COW）机制
   
   给出实现源码,测试用例和设计报告（包括在cow情况下的各种状态转换（类似有限状态自动机）的说明）。
   
   这个扩展练习涉及到本实验和上一个实验“虚拟内存管理”。在ucore操作系统中，当一个用户父进程创建自己的子进程时，父进程会把其申请的用户空间设置为只读，子进程可共享父进程占用的用户内存空间中的页面（这就是一个共享的资源）。当其中任何一个进程修改此用户内存空间中的某页面时，ucore会通过page fault异常获知该操作，并完成拷贝内存页面，使得两个进程都有各自的内存页面。这样一个进程所做的修改不会被另外一个进程可见了。请在ucore中实现这样的COW机制。

2. 说明该用户程序是何时被预先加载到内存中的？与我们常用操作系统的加载有何区别，原因是什么？

## 重要知识点

ucore如何把编译好的用户程序运行起来？

这需要给它分配一些内存，把程序代码加载进来，建立一个进程，然后通过调度让这个用户进程开始执行。

操作系统应当提供给用户程序一些接口，让用户程序使用操作系统提供的服务。这些接口就是**系统调用**。用户程序在用户态运行(U mode), 系统调用在内核态执行(S mode)。这里有一个CPU的特权级切换的过程, 要用到`ecall`指令从U mode进入S mode。

另外，我们总不能让用户程序里直接调用`ecall`。通常我们会把这样的系统调用操作封装成一个个的函数，作为“标准库”提供给用户使用。

对于用户进程的管理，有四个系统调用比较重要。

`sys_fork()`：把当前的进程复制一份，创建一个子进程，原先的进程是父进程。接下来两个进程都会收到`sys_fork()`的返回值，如果返回0说明当前位于子进程中，返回一个非0的值（子进程的PID）说明当前位于父进程中。然后就可以根据返回值的不同，在两个进程里进行不同的处理。

`sys_exec()`：在当前的进程下，停止原先正在运行的程序，开始执行一个新程序。PID不变，但是内存空间要重新分配，执行的机器代码发生了改变。我们可以用`fork()`和`exec()`配合，在当前程序不停止的情况下，开始执行另一个程序。

`sys_exit()`：退出当前的进程。

`sys_wait()`：挂起当前的进程，等到特定条件满足的时候再继续执行。

**内核线程的管理**实现相对是简单的，其特点是直接使用操作系统（比如 ucore）在初始化中建立的内核虚拟内存地址空间，不同的内核线程之间可以通过调度器实现线程间的切换，达到分时使用 CPU 的目的。由于内核虚拟内存空间是一一映射计算机系统的物理空间的，这使得可用空间的大小不会超过物理空间大小，所以操作系统程序员编写内核线程时，需要考虑到有限的地址空间，需要保证各个内核线程在执行过程中不会破坏操作系统的正常运行。这样在实现内核线程管理时，不必考虑涉及与进程相关的虚拟内存管理中的缺页处理、按需分页、写时复制、页换入换出等功能。如果在内核线程执行过程中出现了访存错误异常或内存不够的情况，就认为操作系统出现错误了，操作系统将直接宕机。在 ucore 中，就是调用 `panic()` 函数，进入内核调试监控器 `kernel_debug_monitor`。

**用户进程**是指一个应用程序在操作系统提供的一个用户环境中的一次执行过程。
