# Lab2物理内存和页表

## 一.实验目的

理解页表的建立和使用方法

理解物理内存的管理方法

理解页面分配算法

## 二.实验内容

操作系统为了使用内存，还需高效地管理内存资源。本次实验我们会了解连续物理内存管理，学习如何建立页表来实现虚拟内存到物理内存之间的映射。本次的实验主要是在实验一的基础上完成物理内存管理，并建立一个最简单的页表映射。

### 练习1：理解first-fit 连续物理内存分配算法

仔细阅读实验手册的教程并结合kern/mm/default_pmm.c中的相关代码，认真分析default_init，default_init_memmap，default_alloc_pages， default_free_pages等相关函数，并描述程序在进行物理内存分配的过程以及各个函数的作用。 在实验报告中简要说明设计实现过程。

```
default_init(void) {
    list_init(&free_list);
    nr_free = 0;
}
```

初始化free_list，将其置为空链表，将物理页面数量置为0。

```
default_init_memmap(struct Page *base, size_t n)
```

创建以base为起始地址的连续n个页。将一段连续的物理页面组织成一个链表，并在初始化过程中设置页面的标志位、属性值和引用计数。还更新全局变量nr_free，记录了可用的物理页面数量。最后，根据链表free_list的状态，将base页面插入合适的位置，以维护链表的有序性。

针对每个页面：

```
assert(PageReserved(p));
```

标记页面为已保留状态。

```
p->flags = p->property = 0;
set_page_ref(p, 0);
```

初始化页面的属性、引用计数等字段。

```
base->property = n;
SetPageProperty(base);
```

更新页面块的属性和引用计数。

最后将页面块添加到空闲页面链表，确保链表中页面的顺序正确。这有助于以后的内核内存分配。

```
default_alloc_pages(size_t n)
```

从可用的物理页面链表中分配n个连续的页面，更新链表和全局变量以反映已分配的页面数量，然后返回已分配页面的起始地址。如果无法满足分配请求，函数返回NULL。

检查传入的页面数量是否大于0，否则返回 `NULL`。

如果需求的页面数量大于当前的空闲页面数量，返回 `NULL` 表示分配失败。

遍历空闲页面链表，查找满足需求的页面。

如果找到满足需求的页面，执行以下操作：

- 从链表中移除该页面。
- 如果分配的页面数量小于页面的属性字段，将剩余部分创建为新页面，更新属性和链表。
- 更新空闲页面数量。
- 清除已分配页面的属性。

返回分配的页面或 `NULL`（如果无法满足需求）。

```
default_free_pages(struct Page *base, size_t n)
```

释放一连串物理页面，更新链表和全局变量以反映释放的页面空闲，同时合并相邻的空闲页面，并将释放的页面插入到合适的位置。

检查页面数量是否有效。

针对每个页面，重置页面属性。

更新页面块属性，增加空闲页面数量。

如果空闲页面链表为空，将当前页面添加到链表；否则，按地址顺序插入。

检查并合并前一个相邻页面。

检查并合并后一个相邻页面。

### 练习二：实现 Best-Fit 连续物理内存分配算法

参考kern/mm/default_pmm.c对First Fit算法的实现，编程实现Best Fit页面分配算法，算法的时空复杂度不做要求，能通过测试即可。 请在实验报告中简要说明你的设计实现过程，阐述代码是如何对物理内存进行分配和释放。

Best-Fit：找到的第一个适应分区是大小要求相差最小的空闲分区。

修改代码如下：

```
static struct Page *
best_fit_alloc_pages(size_t n) {
    assert(n > 0);
    if (n > nr_free) {
        return NULL;
    }
    struct Page *page = NULL;
    list_entry_t *le = &free_list;
    size_t min_size = nr_free + 1;
     /*LAB2 EXERCISE 2: YOUR CODE*/ 
    // 下面的代码是first-fit的部分代码，请修改下面的代码改为best-fit
    // 遍历空闲链表，查找满足需求的空闲页框
    // 如果找到满足需求的页面，记录该页面以及当前找到的最小连续空闲页框数量
    while ((le = list_next(le)) != &free_list) {
        struct Page *p = le2page(le, page_link);
        if (p->property >= n && min_size > p->property) {
            page = p;
            min_size = p->property;
        }
    }
    if (page != NULL) {
        list_entry_t* prev = list_prev(&(page->page_link));
        list_del(&(page->page_link));
        if (page->property > n) {
            struct Page *p = page + n;
            p->property = page->property - n;
            SetPageProperty(p);
            list_add(prev, &(p->page_link));
        }
        nr_free -= n;
        ClearPageProperty(page);
    }
    return page;
}
```

首先，检查是否有足够的可用内存页面来满足需求。如果没有足够的页面，返回NULL表示分配失败。接着，初始化一个指向最佳匹配页面的page指针，以及一个迭代链表的指针le。初始化用于跟踪找到的最小连续空闲页面块大小的min_size。进入循环，遍历可用页面的链表，寻找最佳页面块。在循环中，检查每个页面是否满足分配需求，如果满足需求并且比已找到的最小页面块更合适，就更新page和min_size。如果找到了最佳页面块，从链表中删除该页面，并进行必要的更新以反映页面分配。最后，减少可用的空闲页面数量，以反映已分配的页面数量，并返回找到的最佳页面块的指针。

改进策略：

1.搜索策略：可以先将内存块按照大小顺序排序，并建立AVL搜索树计时维护，实现更高效的搜素。

2.碎片整理：Best-Fit算法会使内存块个别来看，外碎片较小；但整体来看会形成较多外碎片。所以当有大块的空闲内存块释放时，及时对已分配的内存进行碎片化整理，合并相邻空闲内存块，减少内存碎片。

3.内存回收：可以对长时间未被访问的内存块进行回收。

## 三.重点知识

### 1.物理地址与虚拟地址

虚拟地址是进程使用的地址空间，而物理地址是硬件实际使用的地址。操作系统的虚拟内存管理层起到了桥梁作用，通过地址映射来管理虚拟地址与物理地址之间的关系，从而实现内存隔离、保护和更灵活的内存分配。这使得操作系统能够有效地管理和优化内存使用。

页表里面记录了程序使用的虚拟页号到实际内存的物理页号的对应关系，但并不是所有的虚拟页都有对应的物理页。虚拟页可能的数目远大于物理页的数目，而且一个程序在运行时，一般不会拥有所有物理页的使用权，而只是将部分物理页在它的页表里进行映射。

### 2.实验执行流程

实验主要完成ucore内核对物理内存的管理工作。

修改entry.S中的kern_entry函数—>调用kern_init函数—>调用pmm_init函数—>调用idt_init函数

kern_entry函数：设置虚拟内存管理，将三级页表的物理地址和Sv39模式位写入satp寄存器，以建立内核的虚拟内存空间，为之后建立分页机制的过程做一个准备。

kern_init函数：完成一些输出并对lab1实验结果的检查。

pmm_init函数：进入物理内存管理初始化的工作，完成物理内存的管理。

idt_init函数：执行中断和异常相关的初始化工作。

在物理内存管理中，首先需要探测可用的物理内存资源,了解到物理内存位于什么地方，有多大之后，就以固定页面大小来划分整个物理内存空间，并准备以此为最小内存分配单位来管理整个物理内存，管理在内核运行过程中每页内存，设定其可用状态（free，used，reserved），接着ucore kernel就要建立页表，启动分页机制，让CPU的MMU把预先建立好的页表中的页表项读入到TLB中，根据页表项描述的虚拟页（Page）与物理页帧（Page Frame）的对应关系完成CPU对内存的读、写和执行操作。

### 3.以页为单位管理物理内存

#### 页表项

在sv39的一个页表项占据8字节（64位）

<img src="file:///C:/Users/鑫鑫/AppData/Roaming/marktext/images/2023-10-14-20-13-57-image.png" title="" alt="" width="658">

 sv39 里面的一个页表项大小为 64 位 8 字节。其中第 53-10 位共44位为一个物理页号，表示这个虚拟页号映射到的物理页号。后面的第 9-0 位共10位则描述映射的状态信息。

RSW：两位留给 S Mode 的应用程序，我们可以用来进行拓展。

D：即 Dirty ，如果 D=1 表示自从上次 D 被清零后，有虚拟地址通过这个页表项进行写入。

A，即 Accessed，如果 A=1 表示自从上次 A 被清零后，有虚拟地址通过这个页表项进行读、或者写、或者取指。

G，即 Global，如果 G=1 表示这个页表项是”全局"的，也就是所有的地址空间（所有的页表）都包含这一项

U，即 user，U为 1 表示用户态 (U Mode)的程序 可以通过该页表项进映射。在用户态运行时也只能够通过 U=1 的页表项进行虚实地址映射。 注意，S Mode 不一定可以通过 U=1 的页表项进行映射。我们需要将 S Mode 的状态寄存器 sstatus 上的 SUM 位手动设置为 1 才可以做到这一点（通常情况不会把它置1）。否则通过 U=1 的页表项进行映射也会报出异常。另外，不论sstatus的SUM位如何取值，S Mode都不允许执行 U=1 的页面里包含的指令，这是出于安全的考虑。

R,W,X 为许可位，分别表示是否可读 (Readable)，可写 (Writable)，可执行 (Executable)。

根据 R,W,X 取值的不同，我们可以分成下面几种类型：

![](C:\Users\鑫鑫\AppData\Roaming\marktext\images\2023-10-14-20-16-49-image.png)

V 表示这个页表项是否合法。如果为 0 表示不合法，此时页表项其他位的值都会被忽略。

#### 多级页表

在实际使用中如果只有一级页表，那么构建出来的虚拟地址空间过于有限，因此需要引入多级页表以实现更大规模的虚拟地址空间。

在Sv39中，因为一个页表项占据8字节（64位），而虚拟地址有39位，后12位是页内偏移，那么还剩下27位可以编码不同的虚拟页号。

如果开个大数组Pagetable[], 给个2^27 虚拟页号都分配8字节的页表项，其中Pagetable[vpn]代表虚拟页号为vpn的虚拟页的页表项，那就是整整1 GiB的内存。但这里面其实很多虚拟地址我们没有用到，会有大片大片的页表项的标志位为0（不合法），那么就浪费了很多内存空间。

因此，我们可以对页表进行“分级”，让它变成一个树状结构。就是把很多页表项组合成一个”大页“，如果这些页表项都非法，那么只需要用一个非法的页表项来覆盖这个大页，而不需要分别建立一大堆非法页表项。很多个大页(megapage)还可以组合起来变成大大页(gigapage!)，继而可以有更大的页，以此类推，当然肯定不是分层越多越好，因为随着层数增多，开销也会越大。

在本次实验中，使用的sv39权衡各方面效率，使用三级页表。有4KiB=4096字节的页，大小为2MiB= 2^21 字节的大页，和大小为1 GiB 的大大页。

在三级页表下，一个39位虚拟地址，可以把它看成9位的“大大页页号”，9位的“大页页号”（也是大大页内的页内偏移），9位的“页号”（大页的页内偏移），还有12位的页内偏移。

整个Sv39的虚拟内存空间里，有512=2^9个大大页，每个大大页里有512个大页，每个大页里有512个页，每个页里有4096个字节，整个虚拟内存空间里就有512∗512∗512∗4096个字节，是512GiB的地址空间。4096/8 = 512，恰好可以在一页里放下512个页表项！

每个一级页表项控制一个虚拟页号，即控制 4KiB 虚拟内存；每个二级页表项则控制 9 位虚拟页号，总计控制 4KiB×2^9 =2MiB 虚拟内存；每个三级页表项控制 18 位虚拟页号，总计控制 2MiB×2^9 =1GiB 虚拟内存。我们可以将二级页表项的 R,W,X 设置为不是全 0 的许可要求，那么它将与一级页表项类似，只不过可以映射一个 2MiB 的大页 (Mega Page) 。同理，也可以将三级页表项看作一个叶子，来映射一个 1GiB 的大大页(Giga Page)。

#### 页表基址

在翻译的过程中，首先需要知道树状页表的根节点的物理地址。这一般保存在一个特殊寄存器里。对于RISCV架构，是一个叫做`satp`的CSR。

![](C:\Users\鑫鑫\AppData\Roaming\marktext\images\2023-10-14-20-47-05-image.png)

MODE表示当前页表的模式：

0000表示不使用页表，直接使用物理地址，在简单的嵌入式系统里用着很方便。

1000表示sv39页表，也就是我们使用的，虚拟内存空间高达`512GiB`。

1001表示Sv48页表，它和Sv39兼容。

其他编码保留备用 ASID（address space identifier）我们目前用不到 OS 可以在内存中为不同的应用分别建立不同虚实映射的页表，并通过修改寄存器 satp 的值指向不同的页表，从而可以修改 CPU 虚实地址映射关系及内存保护的行为。

#### 建立快表访问

在 CPU 内部，使用快表 来记录近期已完成的虚拟页号到物理页号的映射。由于局部性，当要做一个映射时，会有很大可能这个映射在近期被完成过，所以我们可以先到 TLB 里面去查一下，如果有的话我们就可以直接完成映射，而不用访问那么多次内存了。 但是，如果修改了 satp 寄存器，说明我们切换到了一个与先前映射方式完全不同的页表。此时快表里面存储的映射结果就很可能是错误的。这种情况下我们要使用`sfence.vma` 指令刷新整个 TLB 。 同样，在手动修改一个页表项之后，也修改了映射，但 TLB 并不会自动刷新，也需要使用 `sfence.vma` 指令刷新 TLB 。如果不加参数的， `sfence.vma` 会刷新整个 TLB 。
